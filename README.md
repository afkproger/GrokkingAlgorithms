## Бинарный поиск  
    //Бинарный поиск работает только на отсортированных элементах
    // Если количество попыток поиска элемента = кол - ву элементов
    // то время выполнения называют - линейным
    // А бинарный поиск выполняется логарифмическое время
    // 0 - big описывает насколько быстро растёт время выполнения с увеличением кол - ва элементов  

---  

## *Шпаргалка*  


Память компьютера напоминает огромный шкафа с ящиками
Если вам потребуется сохранить набор элементов воспользуйтесь массивом или списком
В массиве все эллементы хранятся в памяти рядом друг с другом
В связанном списке они разбросаны по всей памяти , а в каждом элементе хранится ссылка на следующий
Массивы обеспечивают быстрое чтение
Списки обеспечивают быструю вставку и удаление
Все эллементы Массива должны быть однотипными
Если создать список через *List.of()*, то это будет неизменяемая коллекция => нельзя использовать remove,если вы хотите использовать *List.of()* , то лучше использовать new ArrayList(List.of(...))  

---  

## *Рекурсия и стек*
*Когда функция вызывает саму себя,это называется рекурсией
*В каждой рекурсивной функции должно быть два случая:**базовый**,**рекурсивный**
*Стек поддерживает две операции:занесение и извлечение элементов
*Все вызовы функций сохраняются в стеке вызовов
*Если стек вызовов станет очень большим ,он займёт слишком много памяти  

---  

## Стратегия **Разделяй и властвуй**  

1 . Сначала определяется базлвый случай.Это должен быть простейший случай из всех возможных
2 . Задача делится или сокращается до тех пор , пока не будет сведена к базовому случаю  

В функции ** theTaskOfTheFarmer **