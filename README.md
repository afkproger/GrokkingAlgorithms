## Бинарный поиск  
    //Бинарный поиск работает только на отсортированных элементах
    // Если количество попыток поиска элемента = кол - ву элементов
    // то время выполнения называют - линейным
    // А бинарный поиск выполняется логарифмическое время
    // 0 - big описывает насколько быстро растёт время выполнения с увеличением кол - ва элементов  

---  

## *Шпаргалка*  


Память компьютера напоминает огромный шкафа с ящиками
Если вам потребуется сохранить набор элементов воспользуйтесь массивом или списком
В массиве все эллементы хранятся в памяти рядом друг с другом
В связанном списке они разбросаны по всей памяти , а в каждом элементе хранится ссылка на следующий
Массивы обеспечивают быстрое чтение
Списки обеспечивают быструю вставку и удаление
Все эллементы Массива должны быть однотипными
Если создать список через *List.of()*, то это будет неизменяемая коллекция => нельзя использовать remove,если вы хотите использовать *List.of()* , то лучше использовать new ArrayList(List.of(...))  

---  

## *Рекурсия и стек*
*Когда функция вызывает саму себя,это называется рекурсией
*В каждой рекурсивной функции должно быть два случая:**базовый**,**рекурсивный**
*Стек поддерживает две операции:занесение и извлечение элементов
*Все вызовы функций сохраняются в стеке вызовов
*Если стек вызовов станет очень большим ,он займёт слишком много памяти  

---  

## Стратегия **Разделяй и властвуй**  

1 . Сначала определяется базлвый случай.Это должен быть простейший случай из всех возможных
2 . Задача делится или сокращается до тех пор , пока не будет сведена к базовому случаю  

В функции ** theTaskOfTheFarmer **

##       QuickSort  

Быстрая сортировка основана на стратегии ** разделяй и властвуй **.  
Базовый случай для массивов - если массив пустой или с 1 элементом => он уже отсортирован.  
Как она работает?
1. Выбираем опорный элемент
2. Создаем подмассивы с элементами которые больше опорного,с элементами которые меньше опорного
3. Повторяем шаги (1,2) для этих подмассивов , пока не дойдём до базового случая.А так строим SubList. 
Т.е qiucksort(smallestNums) + pivot + qiucksort(biggestNums)  

---
```java
public class QuickSort {
    public List<Integer> quicksort(List<Integer> list) {
        if (list.size() < 2) {
            return list;
            // Базовый случай
        } else {
            int pivot = list.get(0); // это наша опорная точка
            List<Integer> smallestPivot = new ArrayList<>();  // подмассив для элементов меньше опорной точки
            List<Integer> biggestPivot = new ArrayList<>();   // подмассив для элементов больше опорной точки

            //цикл для отбора подмассивов, нужно не забыть что мы идём от 1 элемента, т.к.опорная точка - нулевой эллемент
            for (int i = 1; i < list.size(); i++) {
                if (list.get(i) <= pivot) {
                    smallestPivot.add(list.get(i));
                } else {
                    biggestPivot.add(list.get(i));
                }
            }
            /**
             * Почему не получалось до этого?
             * Я забывал присвоить smallest and biggest новые значения, т.е. отсортированные массивы
             * Как это выглядело:quicksort(smallestPivot);  quicksort(biggestPivot);
             * Короче, как обычно, накринжевал и сидел довольным
             */

            smallestPivot = quicksort(smallestPivot);
            biggestPivot = quicksort(biggestPivot);

            List<Integer> sortingList = new ArrayList<>(smallestPivot);
            sortingList.add(pivot);
            sortingList.addAll(biggestPivot);

            return sortingList;
        }
    }
}
```